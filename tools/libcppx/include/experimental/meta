// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <iterator>

namespace std::experimental
{
namespace meta {
inline namespace v1 {

// An opaque handle to a reflected entity.
using info = decltype(reflexpr(void));

consteval bool is_variable(info x);
consteval bool is_function(info x);
consteval bool is_enumerator(info x);
consteval bool is_namespace(info x);
consteval bool is_data_member(info x);
consteval bool is_member_function(info x);
consteval bool is_class_type(info x);
consteval bool is_enum_type(info x);

consteval info type_of(info x);

namespace detail {

enum reflection_query : unsigned {
    query_unknown,

    query_is_invalid,
    query_is_entity,
    query_is_unnamed,

    /// Scope
    query_is_local,
    query_is_class_member,

    /// Declarations

    // Variables
    query_is_variable,
    query_has_static_storage,
    query_has_thread_local_storage,
    query_has_automatic_local_storage,

    // Functions
    query_is_function,
    // query_has_ellipsis,

    // Classes
    query_is_class,
    query_has_virtual_destructor,

    // Class Members

    // Data Members
    query_is_static_data_member,
    query_is_nonstatic_data_member,
    query_is_bit_field,

    // Member Functions
    query_is_static_member_function,
    query_is_nonstatic_member_function,
    query_is_override,
    query_is_override_specified,
    query_is_deleted,
    query_is_virtual,
    query_is_pure_virtual,

    // Special Members
    query_is_constructor,
    query_is_default_constructor,
    query_is_copy_constructor,
    query_is_move_constructor,
    query_is_copy_assignment_operator,
    query_is_move_assignment_operator,
    query_is_destructor,
    query_is_defaulted,
    query_is_explicit,

    // Access
    query_has_access,
    query_is_public,
    query_is_protected,
    query_is_private,
    query_has_default_access,

    // Union
    query_is_union,

    // Namespaces and aliases
    query_is_namespace,
    query_is_namespace_alias,
    query_is_type_alias,

    // Enums
    query_is_unscoped_enum,
    query_is_scoped_enum,

    // Enumerators
    query_is_enumerator,

    // Templates
    query_is_template,
    query_is_class_template,
    query_is_alias_template,
    query_is_function_template,
    query_is_variable_template,
    query_is_static_member_function_template,
    query_is_nonstatic_member_function_template,
    query_is_constructor_template,
    query_is_destructor_template,
    query_is_concept,

    // Specializations
    query_is_specialization,
    query_is_partial_specialization,
    query_is_explicit_specialization,
    query_is_implicit_instantiation,
    query_is_explicit_instantiation,

    // Base class specifiers
    query_is_direct_base,
    query_is_virtual_base,

    // Parameters
    query_is_function_parameter,
    query_is_template_parameter,
    query_is_type_template_parameter,
    query_is_nontype_template_parameter,
    query_is_template_template_parameter,
    query_has_default_argument,

    // Types
    query_is_type,
    query_is_fundamental_type,
    query_is_arithmetic_type,
    query_is_scalar_type,
    query_is_object_type,
    query_is_compound_type,
    query_is_function_type,
    query_is_class_type,
    query_is_union_type,
    query_is_unscoped_enum_type,
    query_is_scoped_enum_type,
    query_is_void_type,
    query_is_null_pointer_type,
    query_is_integral_type,
    query_is_floating_point_type,
    query_is_array_type,
    query_is_pointer_type,
    query_is_lvalue_reference_type,
    query_is_rvalue_reference_type,
    query_is_member_object_pointer_type,
    query_is_member_function_pointer_type,
    query_is_closure_type,

    // Type properties
    query_is_incomplete_type,
    query_is_const_type,
    query_is_volatile_type,
    query_is_trivial_type,
    query_is_trivially_copyable_type,
    query_is_standard_layout_type,
    query_is_pod_type,
    query_is_literal_type,
    query_is_empty_type,
    query_is_polymorphic_type,
    query_is_abstract_type,
    query_is_final_type,
    query_is_aggregate_type,
    query_is_signed_type,
    query_is_unsigned_type,
    query_has_unique_object_representations_type,

    // Type operations
    query_is_default_constructible_type,
    query_is_trivially_default_constructible_type,
    query_is_nothrow_default_constructible_type,
    query_is_move_constructible_type,
    query_is_trivially_move_constructible_type,
    query_is_nothrow_move_constructible_type,
    query_is_assignable_type,
    query_is_trivially_assignable_type,
    query_is_nothrow_assignable_type,
    query_is_copy_assignable_type,
    query_is_trivially_copy_assignable_type,
    query_is_nothrow_copy_assignable_type,
    query_is_move_assignable_type,
    query_is_trivially_move_assignable_type,
    query_is_nothrow_move_assignable_type,
    query_is_destructible_type,
    query_is_trivially_destructible_type,
    query_is_nothrow_destructible_type,
    query_is_swappable_type,
    query_is_nothrow_swappable_type,

    // Captures
    query_has_default_ref_capture,
    query_has_default_copy_capture,
    query_is_capture,
    query_is_simple_capture,
    query_is_ref_capture,
    query_is_copy_capture,
    query_is_explicit_capture,
    query_is_init_capture,
    query_has_captures,

    // Expressions
    query_is_expression,
    query_is_lvalue,
    query_is_xvalue,
    query_is_rvalue,
    query_is_value,

    // Traits
    query_get_decl_traits,
    query_get_linkage_traits,
    query_get_access_traits,
    query_get_type_traits,

    // Associated reflections
    query_get_entity,
    query_get_parent,
    query_get_type,
    query_get_return_type,
    query_get_this_ref_type,
    query_get_definition,

    // Traversal
    query_get_begin,
    query_get_next,

    // Name
    query_get_name,
    query_get_display_name
};

static constexpr unsigned get_decl_traits(info x) {
  return __reflect(query_get_decl_traits, x);
}

static constexpr unsigned get_linkage_traits(info x) {
  return __reflect(query_get_linkage_traits, x);
}

static constexpr unsigned get_access_traits(info x) {
  return __reflect(query_get_access_traits, x);
}

static constexpr unsigned get_type_traits(info x) {
  return __reflect(query_get_type_traits, x);
}

// Kinds of linkage.
enum linkage_kind : unsigned {
  lk_external,
  lk_internal,
  lk_none
};

// Kinds of (detectable) storage duration.
enum storage_kind : unsigned {
  sk_automatic,
  sk_thread,
  sk_static
};

// Kinds of class types.
enum class_kind : unsigned {
  ck_struct,
  ck_class,
  ck_union
};

// Kinds of access.
enum access_kind : unsigned {
  ak_none,
  ak_public,
  ak_private,
  ak_protected
};

// Kinds of member functions.
enum member_kind : unsigned {
  mk_normal,
  mk_constructor,
  mk_destructor,
  mk_conversion
};

// The linkage of a bitfield is always stored in the first 2 bits.
static constexpr linkage_kind get_linkage(unsigned n) {
  return linkage_kind(n & 0x03);
}

// Access specifiers are always stored in bits 3 and 4.
static constexpr access_kind get_access(unsigned n) {
  return access_kind((n >> 2) & 0x03);
}

// When present, storage specifiers are stored in bits 5 and 6.
//
// FIXME: This isn't accurate.
static constexpr storage_kind get_storage(unsigned n) {
  return storage_kind((n >> 4) & 0x03);
}

// All named declarations have linkage and access.
struct decl_traits {
  constexpr explicit decl_traits(unsigned n)
    : linkage      (get_linkage(n)), // 0x01 | 0x02
      access       (get_access(n))   // 0x04 | 0x08
  { }

  constexpr explicit decl_traits(info x)
    : decl_traits(get_decl_traits(x))
  { }

  linkage_kind linkage : 2;
  access_kind access : 2;
};

struct variable_traits {
  constexpr explicit variable_traits(unsigned n)
    : linkage      (get_linkage(n)), // 0x01 | 0x02
      access       (get_access(n)),  // 0x04 | 0x08
      storage      (get_storage(n)), // 0x10 | 0x20
      is_constexpr (n & 0x40),
      is_defined   (n & 0x80),
      is_inline    (n & 0x0100)
  { }

  constexpr explicit variable_traits(info x)
    : variable_traits(get_decl_traits(x))
  { assert(is_variable(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
  storage_kind storage : 2;
  bool is_constexpr : 1;
  bool is_defined : 1;
  bool is_inline : 1;
};

struct function_traits {
  constexpr explicit function_traits(unsigned n)
    : linkage      (get_linkage(n)), // 0x01 | 0x02
      access       (get_access(n)),  // 0x04 | 0x08
      is_constexpr (n & 0x10),
      is_noexcept  (n & 0x20),
      is_defined   (n & 0x40),
      is_inline    (n & 0x80),
      is_deleted   (n & 0x0100)
  { }

  constexpr explicit function_traits(info x)
    : function_traits(get_decl_traits(x))
  { assert(is_function(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
  bool is_constexpr : 1;
  bool is_noexcept : 1;
  bool is_defined : 1;
  bool is_inline : 1;
  bool is_deleted : 1;
};

struct value_traits {
  constexpr explicit value_traits(unsigned n)
    : linkage      (get_linkage(n)), // 0x01 | 0x02
      access       (get_access(n))   // 0x04 | 0x08
  { }

  constexpr explicit value_traits(info x)
    : value_traits(get_decl_traits(x))
  { assert(is_enumerator(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
};

struct namespace_traits {
  constexpr explicit namespace_traits(unsigned n)
    : linkage      (get_linkage(n)), // 0x01 | 0x02
      access       (get_access(n)),  // 0x04 | 0x08
      is_inline    (n & 0x10)
  { }

  constexpr explicit namespace_traits(info x)
    : namespace_traits(get_decl_traits(x))
  { assert(is_namespace(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
  bool is_inline : 1;
};

struct field_traits {
  constexpr explicit field_traits(unsigned n)
    : linkage      (get_linkage(n)), // 0x01 | 0x02
      access       (get_access(n)),  // 0x04 | 0x08
      is_mutable   (n & 0x10)
  { }

  constexpr explicit field_traits(info x)
    : field_traits(get_decl_traits(x))
  { assert(is_data_member(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
  bool is_mutable : 1;
};


// Methods

// For methods, the kind is stored in bits 5 and 6.
static constexpr member_kind get_method(unsigned n) {
  return member_kind((n >> 4) & 0x03);
}

struct method_traits {
  constexpr explicit method_traits(unsigned n)
    : linkage        (get_linkage(n)), // 0x01 | 0x02
      access         (get_access(n)),  // 0x04 | 0x08
      kind           (get_method(n)),  // 0x10 | 0x20
      is_constexpr   (n & 0x40),
      is_explicit    (n & 0x80),
      is_virtual     (n & 0x100),
      is_pure        (n & 0x200),
      is_final       (n & 0x400),
      is_override    (n & 0x800),
      is_noexcept    (n & 0x1000),
      is_defined     (n & 0x2000),
      is_inline      (n & 0x4000),
      is_deleted     (n & 0x8000),
      is_defaulted   (n & 0x10000),
      is_trivial     (n & 0x20000),
      is_default_ctor(n & 0x40000),
      is_copy_ctor   (n & 0x80000),
      is_move_ctor   (n & 0x100000),
      is_copy_assign (n & 0x200000),
      is_move_assign (n & 0x400000)
  { }

  constexpr explicit method_traits(info x)
    : method_traits(get_decl_traits(x))
  { assert(is_member_function(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
  member_kind kind : 2;
  bool is_constexpr : 1;
  bool is_explicit : 1;
  bool is_virtual : 1;
  bool is_pure : 1;
  bool is_final : 1;
  bool is_override : 1;
  bool is_noexcept : 1;
  bool is_defined : 1;
  bool is_inline : 1;
  bool is_deleted : 1;
  bool is_defaulted : 1;
  bool is_trivial : 1;
  bool is_default_ctor : 1;
  bool is_copy_ctor : 1;
  bool is_move_ctor : 1;
  bool is_copy_assign : 1;
  bool is_move_assign : 1;
};

// Basic Traits
struct linkage_traits {
  constexpr explicit linkage_traits(unsigned n)
    : kind(get_linkage(n)) { }

  constexpr explicit linkage_traits(info x)
    : linkage_traits(get_linkage_traits(x))
  { }

  linkage_kind kind : 2;
};

struct access_traits {
  constexpr explicit access_traits(unsigned n)
    : kind(get_access(n)) { }

  constexpr explicit access_traits(info x)
    : access_traits(get_access_traits(x))
  { }

  access_kind kind : 2;
};

// Classes

// For classes, the kind is stored in bits 5 and 6.
static constexpr class_kind get_class_kind(unsigned n) {
  return class_kind((n >> 4) & 0x03);
}

// TODO: Accumulate all known type traits for classes.
struct class_traits {
  constexpr explicit class_traits(unsigned n)
    : linkage       (get_linkage(n)),    // 0x01 | 0x02
      access        (get_access(n)),     // 0x04 | 0x08
      kind          (get_class_kind(n)), // 0x10 | 0x20
      is_complete   (n & 0x40),
      is_polymorphic(n & 0x80),
      is_abstract   (n & 0x100),
      is_final      (n & 0x200),
      is_empty      (n & 0x400)
  { }

  constexpr explicit class_traits(info x)
    : class_traits(get_type_traits(x))
  { assert(is_class_type(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
  class_kind kind : 2;
  bool is_complete : 1;
  bool is_polymorphic : 1;
  bool is_abstract : 1;
  bool is_final : 1;
  bool is_empty : 1;
};

struct enum_traits {
  constexpr explicit enum_traits(unsigned n)
    : linkage    (get_linkage(n)), // 0x01 | 0x02
      access     (get_access(n)),  // 0x04 | 0x08
      is_scoped  (n & 0x10),
      is_complete(n & 0x20)
  { }

  constexpr explicit enum_traits(info x)
    : enum_traits(get_type_traits(x))
  { assert(is_enum_type(x)); }

  linkage_kind linkage : 2;
  access_kind access : 2;
  bool is_scoped : 1;
  bool is_complete : 1;
};

} // end internal namespace

// Placeholder for constexpr string.
using string_type = const char*;

// An invalid reflection with the given error message.
consteval info invalid_reflection(string_type error_message) {
  return __invalid_reflection(error_message);
}

/// Classification

// True if x is an invalid reflection.
consteval bool is_invalid(info reflection) {
  return __reflect(detail::query_is_invalid, reflection);
}

/// Enumerators

// True if x reflects an enumerator.
consteval bool is_enumerator(info reflection) {
  return __reflect(detail::query_is_enumerator, reflection);
}

/// Variables

// True if x reflects a variable.
consteval bool is_variable(info reflection) {
  return __reflect(detail::query_is_variable, reflection);
}

consteval bool has_static_storage_duration(info variable) {
  return __reflect(detail::query_has_static_storage, variable);
}

consteval bool has_thread_local_storage_duration(info variable) {
  return __reflect(detail::query_has_thread_local_storage, variable);
}

consteval bool has_automatic_local_storage_duration(info variable) {
  return __reflect(detail::query_has_automatic_local_storage, variable);
}

/// Functions

// True if x reflects a function.
consteval bool is_function(info reflection) {
  return __reflect(detail::query_is_function, reflection);
}

/// Classes

// True if x reflects a class.
consteval bool is_class(info reflection) {
  return __reflect(detail::query_is_class, reflection);
}

// True if x has a virtual destructor, either directly, or via a parent class.
consteval bool has_virtual_destructor(info class_type) {
  return __reflect(detail::query_has_virtual_destructor, class_type);
}

// True if x reflects a union.
consteval bool is_union(info x) {
  return __reflect(detail::query_is_union, x);
}

// True if x reflects an enum.
consteval bool is_enum(info x) {
  return __reflect(detail::query_is_unscoped_enum, x);
}

// True if x reflects a scoped enum.
consteval bool is_scoped_enum(info x) {
  return __reflect(detail::query_is_scoped_enum, x);
}

/// Class Members

/// Data Members

// True if x reflects a static data member.
consteval bool is_static_data_member(info reflection) {
  return __reflect(detail::query_is_static_data_member, reflection);
}

// True if x reflects a nonstatic data member.
consteval bool is_nonstatic_data_member(info reflection) {
  return __reflect(detail::query_is_nonstatic_data_member, reflection);
}

// True if x reflects a data member.
consteval bool is_data_member(info reflection) {
  return is_nonstatic_data_member(reflection) || is_static_data_member(reflection);
}

// True if x reflects a bit field.
consteval bool is_bit_field(info reflection) {
  return __reflect(detail::query_is_bit_field, reflection);
}

/// Member Functions

// True if x reflects a static member function.
consteval bool is_static_member_function(info reflection) {
  return __reflect(detail::query_is_static_member_function, reflection);
}

// True if x reflects a nonstatic member function.
consteval bool is_nonstatic_member_function(info reflection) {
  return __reflect(detail::query_is_nonstatic_member_function, reflection);
}

// True if x reflects a member function.
consteval bool is_member_function(info reflection) {
  return is_nonstatic_member_function(reflection) || is_static_member_function(reflection);
}

consteval bool is_override(info mem_function) {
  return __reflect(detail::query_is_override, mem_function);
}

consteval bool is_override_specified(info mem_function) {
  return __reflect(detail::query_is_override, mem_function);
}

consteval bool is_deleted(info mem_function) {
  return __reflect(detail::query_is_deleted, mem_function);
}

consteval bool is_virtual(info mem_function) {
  return __reflect(detail::query_is_virtual, mem_function);
}

consteval bool is_pure_virtual(info mem_function) {
  return __reflect(detail::query_is_pure_virtual, mem_function);
}

/// Special Members

// True if x reflects a constructor.
consteval bool is_constructor(info reflection) {
  return __reflect(detail::query_is_constructor, reflection);
}

// True if x reflects a default constructor.
consteval bool is_default_constructor(info reflection) {
  return __reflect(detail::query_is_default_constructor, reflection);
}

// True if x reflects a copy constructor.
consteval bool is_copy_constructor(info reflection) {
  return __reflect(detail::query_is_copy_constructor, reflection);
}

// True if x reflects a move constructor.
consteval bool is_move_constructor(info reflection) {
  return __reflect(detail::query_is_move_constructor, reflection);
}

// True if x reflects a copy assignment operator.
consteval bool is_copy_assignment_operator(info reflection) {
  return __reflect(detail::query_is_copy_assignment_operator, reflection);
}

// True if x reflects a move assignment operator.
consteval bool is_move_assignment_operator(info reflection) {
  return __reflect(detail::query_is_move_assignment_operator, reflection);
}

// True if x reflects a destructor.
consteval bool is_destructor(info reflection) {
  return __reflect(detail::query_is_destructor, reflection);
}

consteval bool is_defaulted(info spec_mem_function) {
  return __reflect(detail::query_is_defaulted, spec_mem_function);
}

consteval bool is_explicit(info spec_mem_function) {
  return __reflect(detail::query_is_explicit, spec_mem_function);
}

/// Access

consteval bool has_access(info reflection) {
  return __reflect(detail::query_has_access, reflection);
}

consteval bool is_public(info base_or_mem) {
  return __reflect(detail::query_is_public, base_or_mem);
}

consteval bool is_protected(info base_or_mem) {
  return __reflect(detail::query_is_protected, base_or_mem);
}

consteval bool is_private(info base_or_mem) {
  return __reflect(detail::query_is_private, base_or_mem);
}

consteval bool has_default_access(info base_or_mem) {
  return __reflect(detail::query_has_default_access, base_or_mem);
}

// True if x reflects a type.
consteval bool is_type(info x) {
  return __reflect(detail::query_is_type, x);
}

// True if x reflects a function type.
consteval bool is_function_type(info x) {
  return __reflect(detail::query_is_function_type, x);
}

// True if x reflects an entity with function type.
consteval bool has_function_type(info x) {
  return is_function_type(type_of(x));
}

// True if x reflects a class type.
consteval bool is_class_type(info x) {
  return __reflect(detail::query_is_class_type, x);
}

// True if x reflects an entity with class type.
consteval bool has_class_type(info x) {
  return is_class_type(type_of(x));
}

// True if x reflects a union type.
consteval bool is_union_type(info x) {
  return __reflect(detail::query_is_union_type, x);
}

// True if x reflects an entity with union type.
consteval bool has_union_type(info x) {
  return is_union_type(type_of(x));
}

// True if x reflects an enum type.
consteval bool is_enum_type(info x) {
  return __reflect(detail::query_is_enum_type, x);
}

// True if x reflects an entity with enum type.
consteval bool has_enum_type(info x) {
  return is_enum_type(type_of(x));
}

// True if x reflects a scoped enum type.
consteval bool is_scoped_enum_type(info x) {
  return __reflect(detail::query_is_scoped_enum_type, x);
}

// True if x reflects an entity with scoped enum type.
consteval bool has_scoped_enum_type(info x) {
  return is_scoped_enum_type(type_of(x));
}

// True if x reflects an entity with void type.
consteval bool is_void_type(info x) {
  return __reflect(detail::query_is_void_type, x);
}

// True if x reflects an entity with void type.
consteval bool has_void_type(info x) {
  return is_void_type(type_of(x));
}

// True if x reflects a null pointer type.
consteval bool is_null_pointer_type(info x) {
  return __reflect(detail::query_is_null_pointer_type, x);
}

// True if x reflects an entity with null pointer type.
consteval bool has_null_pointer_type(info x) {
  return is_null_pointer_type(type_of(x));
}

// True if x reflects an integral type.
consteval bool is_integral_type(info x) {
  return __reflect(detail::query_is_integral_type, x);
}

// True if x reflects an entity with integral type.
consteval bool has_integeral_type(info x) {
  return is_integral_type(type_of(x));
}

// True if x reflects a floating point type.
consteval bool is_floating_point_type(info x) {
  return __reflect(detail::query_is_floating_point_type, x);
}

// True if x reflects an entity with floating point type.
consteval bool has_floating_point_type(info x) {
  return is_floating_point_type(type_of(x));
}

// True if x reflects an array type.
consteval bool is_array_type(info x) {
  return __reflect(detail::query_is_array_type, x);
}

// True if x reflects an entity with array type.
consteval bool has_array_type(info x) {
  return is_array_type(type_of(x));
}

// True if x reflects a pointer type.
consteval bool is_pointer_type(info x) {
  return __reflect(detail::query_is_pointer_type, x);
}

// True if x reflects an entity with pointer type.
consteval bool has_pointer_type(info x) {
  return is_pointer_type(type_of(x));
}

// True if x reflects a lvalue reference type.
consteval bool is_lvalue_reference_type(info x) {
  return __reflect(detail::query_is_lvalue_reference_type, x);
}

// True if x reflects an entity with lvalue reference type.
consteval bool has_lvalue_reference_type(info x) {
  return is_lvalue_reference_type(type_of(x));
}

// True if x reflets a rvalue reference type.
consteval bool is_rvalue_reference_type(info x) {
  return __reflect(detail::query_is_rvalue_reference_type, x);
}

// True if x reflets an entity with rvalue reference type.
consteval bool has_rvalue_reference_type(info x) {
  return is_rvalue_reference_type(type_of(x));
}

// True if x reflects a member object pointer type.
consteval bool is_member_object_pointer_type(info x) {
  return __reflect(detail::query_is_member_object_pointer_type, x);
}

// True if x reflects an entity with member object pointer type.
consteval bool has_member_object_pointer_type(info x) {
  return is_member_object_pointer_type(type_of(x));
}

// True if x reflects a member function pointer type.
consteval bool is_member_function_pointer_type(info x) {
  return __reflect(detail::query_is_member_object_pointer_type, x);
}

// True if x reflects an entity with member function pointer type.
consteval bool has_member_function_pointer_type(info x) {
  return is_member_function_pointer_type(type_of(x));
}

// True if x reflects a closure type.
consteval bool is_closure_type(info x) {
  return __reflect(detail::query_is_closure_type, x);
}

// True if x reflects an entity with closure type.
consteval bool has_closure_type(info x) {
  return is_closure_type(type_of(x));
}

// True if x reflects a namespace.
consteval bool is_namespace(info x) {
  return __reflect(detail::query_is_namespace, x);
}

// True if x reflects a namespace alias.
consteval bool is_namespace_alias(info x) {
  return __reflect(detail::query_is_namespace_alias, x);
}

// True if x reflects a type alias.
consteval bool is_type_alias(info x) {
  return __reflect(detail::query_is_type_alias, x);
}

// True if x reflects a template.
consteval bool is_template(info x) {
  return __reflect(detail::query_is_template, x);
}

// True if x reflects a class template.
consteval bool is_class_template(info x) {
  return __reflect(detail::query_is_class_template, x);
}

// True if x reflects a alias template.
consteval bool is_alias_template(info x) {
  return __reflect(detail::query_is_alias_template, x);
}

// True if x reflects a function template.
consteval bool is_function_template(info x) {
  return __reflect(detail::query_is_function_template, x);
}

// True if x reflects a variable template.
consteval bool is_variable_template(info x) {
  return __reflect(detail::query_is_variable_template, x);
}

// True if x refects a static member function template.
consteval bool is_static_member_function_template(info x) {
  return __reflect(detail::query_is_static_member_function_template, x);
}

// True if x reflects a nonstatic member function template.
consteval bool is_member_function_template(info x) {
  return __reflect(detail::query_is_nonstatic_member_function_template, x);
}

// True if x reflects a constructor template.
consteval bool is_constructor_template(info x) {
  return __reflect(detail::query_is_constructor_template, x);
}

// True if x reflects a destructor template.
consteval bool is_destructor_template(info x) {
  return __reflect(detail::query_is_destructor_template, x);
}

// True if x reflects a concept.
consteval bool is_concept(info x) {
  return __reflect(detail::query_is_concept, x);
}

// True if x reflects a specialization.
consteval bool is_specialization(info x) {
  return __reflect(detail::query_is_specialization, x);
}

// True if x reflects a partial specialization.
consteval bool is_partial_specialization(info x) {
  return __reflect(detail::query_is_partial_specialization, x);
}

// True if x reflects an explicit specialization.
consteval bool is_explicit_specialization(info x) {
  return __reflect(detail::query_is_explicit_specialization, x);
}

// True if x reflects an implicit instantiation.
consteval bool is_implicit_instantiation(info x) {
  return __reflect(detail::query_is_implicit_instantiation, x);
}

// True if x reflects an explicit instantiation.
consteval bool is_explicit_instantiation(info x) {
  return __reflect(detail::query_is_explicit_instantiation, x);
}

// True if x reflects a direct base.
consteval bool is_direct_base(info x) {
  return __reflect(detail::query_is_direct_base, x);
}

// True if x reflects a virtual base.
consteval bool is_virtual_base(info x) {
  return __reflect(detail::query_is_virtual_base, x);
}

// True if x reflects a function parameter.
consteval bool is_function_parameter(info x) {
  return __reflect(detail::query_is_function_parameter, x);
}

// True if x reflects a template parameter.
consteval bool is_template_parameter(info x) {
  return __reflect(detail::query_is_template_parameter, x);
}

// True if x reflects a type template parameter.
consteval bool is_type_template_parameter(info x) {
  return __reflect(detail::query_is_type_template_parameter, x);
}

// True if x reflects a type template parameter.
consteval bool is_nontype_template_parameter(info x) {
  return __reflect(detail::query_is_nontype_template_parameter, x);
}

// True if x reflects a template template parameter.
consteval bool is_template_template_parameter(info x) {
  return __reflect(detail::query_is_template_template_parameter, x);
}

// True if x reflects an expression.
consteval bool is_expression(info x) {
  return __reflect(detail::query_is_expression, x);
}

// True if x reflects an lvalue expression.
consteval bool is_lvalue(info x) {
  return __reflect(detail::query_is_lvalue, x);
}

// True if x reflects an xvalue expression.
consteval bool is_xvalue(info x) {
  return __reflect(detail::query_is_xvalue, x);
}

// True if x reflects an rvalue expression.
consteval bool is_rvalue(info x) {
  return __reflect(detail::query_is_xvalue, x);
}

// True if x reflects a value.
consteval bool is_value(info x) {
  return __reflect(detail::query_is_value, x);
}

// -------------------------------------------------------------------------- //
// Associated reflection queries

// Returns the reflected entity.
consteval info entity_of(info x) {
  return __reflect(detail::query_get_entity, x);
}

// Returns the lexical context of the declaration.
consteval info parent_of(info x) {
  return __reflect(detail::query_get_parent, x);
}

// Returns the type of the entity.
consteval info type_of(info x) {
  return __reflect(detail::query_get_type, x);
}

// Returns the type of the entity.
consteval info return_type_of(info x) {
  return __reflect(detail::query_get_return_type, x);
}

// Returns the definition of the reflected user defined type.
consteval info definition_of(info x) {
  return __reflect(detail::query_get_definition, x);
}

// -------------------------------------------------------------------------- //
// Traversal queries

// Returns the first child of declaration context. This can be used with
// next() to traverse contexts as template arguments (iterators don't work
// as template arguments).
consteval info front(info x) {
  return __reflect(detail::query_get_begin, x);
}

// Returns the next info in the sequence.
consteval info next(info x) {
  return __reflect(detail::query_get_next, x);
}

class iterator {
  meta::info m_info;

public:
  using value_type = info;
  using reference = info;
  using pointer = info;
  using difference_type = std::ptrdiff_t;
  using iterator_category = std::forward_iterator_tag;

  constexpr iterator()
    : m_info()
  { }

  constexpr iterator(meta::info x)
    : m_info(front(x))
  { }

  constexpr meta::info operator*() const {
    return m_info;
  }

  constexpr iterator operator++() {
    m_info = next(m_info);
    return *this;
  }

  constexpr iterator operator++(int) {
    iterator tmp = *this;
    operator++();
    return tmp;
  }

  constexpr friend bool operator==(iterator a, iterator b) {
    return a.m_info == b.m_info;
  }

  constexpr friend bool operator!=(iterator a, iterator b) {
    return a.m_info != b.m_info;
  }
};

class range {
  iterator m_first;
  iterator m_last;

public:
  constexpr range() { }

  constexpr range(info cxt)
    : m_first(cxt), m_last()
  { }

  constexpr iterator begin() const { return m_first; }

  constexpr iterator end() const { return m_last; }
};

// Returns the first sub-object of x. Objects behave
// as forward iterators.
constexpr iterator begin(info x) {
  return __reflect(detail::query_get_begin, x);
}

// Returns a null sub-object of x, indicating
// the end of a sequence.
//
// FIXME: This seems to mean that we don't actually need __reflect_end.
constexpr iterator end(info x) {
  return iterator();
}

// Overload distance so that it's constexpr.
constexpr std::ptrdiff_t distance(iterator first, iterator last) {
  std::ptrdiff_t n = 0;
  for (; first != last; ++first)
    ++n;
  return n;
}

// -------------------------------------------------------------------------- //
// Scope queries

// True if x is in local scope.
consteval bool is_local(info reflection) {
  return __reflect(detail::query_is_local, reflection);
}

// True if x is a member of a class.
consteval bool is_class_member(info x) {
  return __reflect(detail::query_is_class_member, x);
}

// -------------------------------------------------------------------------- //
// Name

consteval string_type name_of(info x) {
  return __reflect(detail::query_get_name, x);
}

consteval string_type display_name_of(info x) {
  return __reflect(detail::query_get_display_name, x);
}

// -------------------------------------------------------------------------- //
// General purpose queries

consteval bool has_linkage(info x) {
  return detail::linkage_traits(x).kind != detail::lk_none;
}

consteval bool has_external_linkage(info x) {
  return detail::linkage_traits(x).kind == detail::lk_external;
}

consteval bool has_internal_linkage(info x) {
  return detail::linkage_traits(x).kind == detail::lk_internal;
}

consteval bool is_extern(info x) {
  assert(has_linkage(x));
  return detail::linkage_traits(x).kind == detail::lk_external;
}

consteval bool is_inline(info x) {
  if (is_namespace(x))
    return detail::namespace_traits(x).is_inline;
  if (is_variable(x))
    return detail::variable_traits(x).is_inline;
  if (is_member_function(x))
    return detail::method_traits(x).is_inline;
  if (is_function(x))
    return detail::function_traits(x).is_inline;
  if (is_member_function_template(x))
    return detail::method_traits(x).is_inline;

  assert(false);
}

consteval bool is_constexpr(info x) {
  if (is_variable(x))
    return detail::variable_traits(x).is_constexpr;
  if (is_member_function(x))
    return detail::method_traits(x).is_constexpr;
  if (is_function(x))
    return detail::function_traits(x).is_constexpr;
  if (is_member_function_template(x))
    return detail::method_traits(x).is_constexpr;

  assert(false);
}

consteval bool is_normal(info x) {
  return detail::method_traits(x).kind == detail::mk_normal;
}

consteval bool is_conversion(info x) {
  return detail::method_traits(x).kind == detail::mk_conversion;
}

consteval bool is_final(info x) {
  if (is_class_type(x))
    return detail::class_traits(x).is_final;
  if (is_member_function(x))
    return detail::method_traits(x).is_final;

  assert(false);
}

consteval bool is_mutable(info x) {
  return detail::field_traits(x).is_mutable;
}

consteval bool is_defined(info x) {
  if (is_variable(x))
    return detail::variable_traits(x).is_defined;
  if (is_member_function(x))
    return detail::method_traits(x).is_defined;
  if (is_function(x))
    return detail::function_traits(x).is_defined;
  if (is_class_type(x))
    return detail::class_traits(x).is_complete;
  if (is_data_member(x))
    return true;

  assert(false);
}

consteval bool is_declared_struct(info x) {
  return detail::class_traits(x).kind == detail::ck_struct;
}

consteval bool is_declared_class(info x) {
  return detail::class_traits(x).kind == detail::ck_class;
}

consteval bool is_complete(info x) {
  if (is_class_type(x))
    return detail::class_traits(x).is_complete;
  if (is_enum_type(x))
    return detail::enum_traits(x).is_complete;

  assert(false);
}

// consteval bool is_injected_class_name(info x) {
//   return detail::class_traits(x).is_injected;
// }

consteval bool is_scoped(info x) {
  return detail::enum_traits(x).is_scoped;
}

} // inline namespace v1
} // namespace meta
} // namespace std::experimental


#endif // CPPX_META
